ESP32 con 16Mb.

Existen placas ESP32 con 16Mb de memoria en vez de los 4Mb habituales.
Para estos casos no hay una configuración en el IDE de Arduino que permita
aprovechar el total de la memoria.

Modificaremos la definición de placas del IDE de Arduino, creando una nueva
que de adapte a esta configuración.

Los archivos que nos interesan son:
  boards.txt
    Contiene la definición de las placas:
    - Tipo de procesador
    - Frecuencias de procesador
    - Tamaño de memoria
    - Particiones de memoria disponibles
    - Velocidades de transmisión
    - etc
    Se encuentra en la carpeta arduino-1.8.5/hardware/espressif/esp32
  Archivos de particiones
    Contienen la definición de cómo debe distribuirse la memoria
    Se encuentran en la carpeta arduino-1.8.5/hardware/espressif/esp32/tools/partitions
    Tienen extensión y formato csv.
    Ya hay unos cuantos definidos.

Comenzamos creando una copia de seguridad de boards.txt y editándolo.
Añadiremos las siguientes líneas al final del archivo:
----inicio de texto----

##############################################################

esp32_16MB.name=ESP32 Dev Module 16MB

esp32_16MB.upload.tool=esptool
esp32_16MB.upload.maximum_size=8323072
esp32_16MB.upload.maximum_data_size=1048576
esp32_16MB.upload.wait_for_upload_port=true

esp32_16MB.serial.disableDTR=true
esp32_16MB.serial.disableRTS=true

esp32_16MB.build.mcu=esp32
esp32_16MB.build.core=esp32
esp32_16MB.build.variant=esp32
esp32_16MB.build.board=ESP32_DEV

esp32_16MB.build.f_cpu=240000000L
esp32_16MB.build.flash_size=16MB
esp32_16MB.build.flash_freq=40m
esp32_16MB.build.flash_mode=dio
esp32_16MB.build.boot=dio
esp32_16MB.build.partitions=16default
esp32_16MB.build.defines=

esp32_16MB.menu.PSRAM.disabled=Disabled
esp32_16MB.menu.PSRAM.disabled.build.defines=
esp32_16MB.menu.PSRAM.enabled=Enabled
esp32_16MB.menu.PSRAM.enabled.build.defines=-DBOARD_HAS_PSRAM -mfix-esp32-psram-cache-issue

esp32_16MB.menu.PartitionScheme.16default=16MB Default
esp32_16MB.menu.PartitionScheme.16default.build.partitions=16default
esp32_16MB.menu.PartitionScheme.16default.upload.maximum_size=2097152
esp32_16MB.menu.PartitionScheme.16default.upload.maximum_data_size=1048576
esp32_16MB.menu.PartitionScheme.16min_spiffs=16MB Minimal SPIFFS
esp32_16MB.menu.PartitionScheme.16min_spiffs.build.partitions=16min_spiffs
esp32_16MB.menu.PartitionScheme.16min_spiffs.upload.maximum_size=8323072
esp32_16MB.menu.PartitionScheme.16min_spiffs.upload.maximum_data_size=4161536
esp32_16MB.menu.PartitionScheme.16no_ota=16MB No OTA
esp32_16MB.menu.PartitionScheme.16no_ota.build.partitions=16no_ota
esp32_16MB.menu.PartitionScheme.16no_ota.upload.maximum_size=2097152
esp32_16MB.menu.PartitionScheme.16no_ota.upload.maximum_data_size=1048576
esp32_16MB.menu.PartitionScheme.default=4MB Default
esp32_16MB.menu.PartitionScheme.default.build.partitions=default
esp32_16MB.menu.PartitionScheme.no_ota=4MB No OTA
esp32_16MB.menu.PartitionScheme.no_ota.build.partitions=no_ota
esp32_16MB.menu.PartitionScheme.no_ota.upload.maximum_size=2097152
esp32_16MB.menu.PartitionScheme.min_spiffs=4MB Minimal SPIFFS
esp32_16MB.menu.PartitionScheme.min_spiffs.build.partitions=min_spiffs
esp32_16MB.menu.PartitionScheme.min_spiffs.upload.maximum_size=1966080
esp32_16MB.menu.PartitionScheme.minimal=2MB Default
esp32_16MB.menu.PartitionScheme.minimal.build.partitions=minimal

esp32_16MB.menu.FlashMode.qio=QIO
esp32_16MB.menu.FlashMode.qio.build.flash_mode=dio
esp32_16MB.menu.FlashMode.qio.build.boot=qio
esp32_16MB.menu.FlashMode.dio=DIO
esp32_16MB.menu.FlashMode.dio.build.flash_mode=dio
esp32_16MB.menu.FlashMode.dio.build.boot=dio
esp32_16MB.menu.FlashMode.qout=QOUT
esp32_16MB.menu.FlashMode.qout.build.flash_mode=dout
esp32_16MB.menu.FlashMode.qout.build.boot=qout
esp32_16MB.menu.FlashMode.dout=DOUT
esp32_16MB.menu.FlashMode.dout.build.flash_mode=dout
esp32_16MB.menu.FlashMode.dout.build.boot=dout

esp32_16MB.menu.FlashFreq.80=80MHz
esp32_16MB.menu.FlashFreq.80.build.flash_freq=80m
esp32_16MB.menu.FlashFreq.40=40MHz
esp32_16MB.menu.FlashFreq.40.build.flash_freq=40m

esp32_16MB.menu.FlashSize.16M=16MB (128Mb)
esp32_16MB.menu.FlashSize.16M.build.flash_size=16MB
esp32_16MB.menu.FlashSize.4M=4MB (32Mb)
esp32_16MB.menu.FlashSize.4M.build.flash_size=4MB
esp32_16MB.menu.FlashSize.2M=2MB (16Mb)
esp32_16MB.menu.FlashSize.2M.build.flash_size=2MB
esp32_16MB.menu.FlashSize.2M.build.partitions=minimal

esp32_16MB.menu.UploadSpeed.921600=921600
esp32_16MB.menu.UploadSpeed.921600.upload.speed=921600
esp32_16MB.menu.UploadSpeed.115200=115200
esp32_16MB.menu.UploadSpeed.115200.upload.speed=115200
esp32_16MB.menu.UploadSpeed.256000.windows=256000
esp32_16MB.menu.UploadSpeed.256000.upload.speed=256000
esp32_16MB.menu.UploadSpeed.230400.windows.upload.speed=256000
esp32_16MB.menu.UploadSpeed.230400=230400
esp32_16MB.menu.UploadSpeed.230400.upload.speed=230400
esp32_16MB.menu.UploadSpeed.460800.linux=460800
esp32_16MB.menu.UploadSpeed.460800.macosx=460800
esp32_16MB.menu.UploadSpeed.460800.upload.speed=460800
esp32_16MB.menu.UploadSpeed.512000.windows=512000
esp32_16MB.menu.UploadSpeed.512000.upload.speed=512000

esp32_16MB.menu.DebugLevel.none=None
esp32_16MB.menu.DebugLevel.none.build.code_debug=0
esp32_16MB.menu.DebugLevel.error=Error
esp32_16MB.menu.DebugLevel.error.build.code_debug=1
esp32_16MB.menu.DebugLevel.warn=Warn
esp32_16MB.menu.DebugLevel.warn.build.code_debug=2
esp32_16MB.menu.DebugLevel.info=Info
esp32_16MB.menu.DebugLevel.info.build.code_debug=3
esp32_16MB.menu.DebugLevel.debug=Debug
esp32_16MB.menu.DebugLevel.debug.build.code_debug=4
esp32_16MB.menu.DebugLevel.verbose=Verbose
esp32_16MB.menu.DebugLevel.verbose.build.code_debug=5

----fin de texto----
Con esto creamos una nueva placa con identificador esp32_16Mb basada en la esp32, que es
la genérica (ESP32 Dev Module).
El nombre asignado es "ESP32 Dev Module 16MB".
Mantendremos los esquemas de particiones habituales por si queremos trabajar con 2 o 4Mb, pero añadimos
alguno nuevo que comentaremos más adelante.

Recordemos que ESP32 hace 7 particiones en su memoria: base, nvs, otadata, app0, app1, eeprom spiffs.
Las más grandes son app0, app1 y spiffs.
  app0 alberga el programa principal y las variables creadas en tiempo de ejecución.
  app1 es el espacio de almacenamiento temporal de OTA.
  spiffs es el sistema de archivos accesibles desde el programa.

El parámetro esp32_16MB.upload.maximum_size define de manera global y para todos los esquemas el tamaño
máximo que puede tener un programa al cargar un programa.
Debería coincidir con el tamaño de la partición app0, pero como no es obligatorio que todas las
particiones sean iguales, se puede reescribir en la definición de esquemas con el parámetro:
  esp32_16MB.menu.PartitionScheme.no_ota.upload.maximum_size
Por esta razón dejaremos el valor más común en el parámetro global, pero incluiremos siempre el mismo
parámetro al definir los esquemas.
Algo similar ocurre con el parámetro esp32_16MB.upload.maximum_data_size, que indica el tamaño de
memoria máximo que puede utilizar un programa para variables.
Puesto que en la partición app0 conviven el programa y sus variables, este valor nunca podrá ser
mayor que el tamaño de la partición app0. Como norma general y para flexibilidar la regla por defecto
de estas placas, indicaremos que las variables pueden ocupar como máximo la mitad de la partición.
En el parámetro global indicaremos el valor más común, pero en este caso también tenemos un parámetro
que lo sobreescribe en la definición de cada esquema:
  esp32_16MB.menu.PartitionScheme.16min_spiffs.upload.maximum_data_size
También incluiremos este parámetro en todas las nuevas definiciones, por seguridad.

16Mb en hexadecimal son 0x1000000 bytes
Esta es la cantidad de memoria que debemos distribuir en distintas particiones.
En todos los esquemas se conservan las particiones de nvs y otadata en las mismas posiciones y con los
mismos tamaños:
  # Name,   Type, SubType, Offset,  Size, Flags
  nvs,      data, nvs,     0x9000,  0x5000,
  otadata,  data, ota,     0xe000,  0x2000,
También debemos recordar incluir una partición para simular la memoria eeprom.
La pondremos detrás de las particiones de memoria de programa (normal y OTA) y siempre con un
tamaño de 0x2000 bytes = 8192 bytes = 8Kb
De todas las posibilidades existentes sólo tomaremos aquellas que nos resulten más prácticas:
  16default
    Esquema versátil. Debería servir para cualquier cosa. No debe estar limitado en nada.
    Asignaremos 2Mb a la partición app0 para guardar el programa principal.
    El mismo tamaño para app0 para tener la posibilidad de utilizar OTA.
    El espacio restante irá para spiffs (más de 12Mb).
    El archivo 16default.csv debería contener el siguiente texto:
----inicio de texto----
# Name,   Type, SubType, Offset,  Size, Flags
nvs,      data, nvs,     0x9000,  0x5000,
otadata,  data, ota,     0xe000,  0x2000,
app0,     app,  ota_0,   0x10000, 0x200000,
app1,     app,  ota_1,   0x210000,0x200000,
eeprom,   data, 0x99,    0x410000,0x2000,
spiffs,   data, spiffs,  0x412000,0xBEE000,
----fin de texto----
  16min_spiffs
    Esquema especialmente creado para trabajar con programas muy grandes que requieran OTA.
    La partición SPIFFS se reduce al máximo y el resto de memoria se divide por igual entre
    app0 y app1.
    El archivo 16min_spiffs.csv debería contene el siguiente texto.
----inicio de texto----
# Name,   Type, SubType, Offset,  Size, Flags
nvs,      data, nvs,     0x9000,  0x5000,
otadata,  data, ota,     0xe000,  0x2000,
app0,     app,  ota_0,   0x10000, 0x7F0000,
app1,     app,  ota_1,   0x800000,0x7F0000,
eeprom,   data, 0x99,    0xFF0000,0x1000,
spiffs,   data, spiffs,  0xFF1000,0xF000,
----fin de texto----
  16no_ota
    Esquema que maximiza la partición spiffs, eliminando la posibilidad de usar OTA.
    La partición de programa principal se mantiene en 2Mb. Debería ser suficiente.
    El archivo 16no_ota.csv debería contene el siguiente texto.
----inicio de texto----
# Name,   Type, SubType, Offset,  Size, Flags
nvs,      data, nvs,     0x9000,  0x5000,
otadata,  data, ota,     0xe000,  0x2000,
app0,     app,  ota_0,   0x10000, 0x200000,
eeprom,   data, 0x99,    0x210000,0x1000,
spiffs,   data, spiffs,  0x211000,0xDEF000,
----fin de texto----


Resumimos los esquemas creados y memorias utilizadas:

Partition Scheme    app0    app1    spiffs   var
------------------- ------- ------- -------- -------
16Mb Default        2097152 2097152 12509184 1048576
16Mb Minimal SPIFFS 8323072 8323072    61440 4161536
16Mb No OTA         2097152       0 14610432 1048576

Nota:
Cuando se utiliza el plugin de transferencia de datos a SPIFFS en el IDE de Arduino,
al igual que con los programas, la información se comprime antes de tranferirla y en la placa
se descomprime mientras se recibe.
Si la partición spiffs es grande, es posible que aunque el tiempo de transferencia sea reducido,
la placa necesite tiempo para llenar todas las posiciones de memoria de la partición.
Esto podría llevar incluso más de un minuto.
